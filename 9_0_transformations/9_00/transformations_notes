Transformations Notes

Functions:

translate()
rotate()
scale()

push()
pop()

Example:

rect(50, 50, 100, 50);

is the same as

translate(50, 50);
rect(0, 0, 100, 50);

because translate moves the point of origin
0, 0 is now where 50, 50 was originally

Translations accumulate so they apply to further shapes

Need translate to control the rotation of a shape
Rotations happens around the point of origin so need to translate this point

Angle:

Using degrees

angleMode(DEGREES)

Radians:

Arc length
-"Unit circle" is a circle with a radius of length 1
-Create an angle, flatten and measure length to know radian
-Calculate circumference of a circle = 2 * PI * r
-Circumference of a "unit circle" is 2 * PI (because r = 1)

push() --> save
pop() --> restore

Scale()

-stretches everything out or shrinks everything relative to 0, 0
-scale(_)
-scale(_,_)
-can scale the same on both x and y axis
-or do 1 thing to the x axis and another on the y axis
-can use negative numbers

1 = 100%, default scale
2 = object will be twice as big (200%)
0.5 = shrunk by 50%

-negative numbers flip the axis (e.g. change y to pointing down instead of up)

-push() and pop() can be used to save style information e.g. stroke(), fill()
etc.
-can use one pop() for every push() - can only restore the same amount of
information you've saved

STACK
-push() and pop() save information in a stack
-push() adds to stack
-pop() takes the last thing out

QUEUE
-The first item in queue is the first to be taken out

p5.js reference

https://p5js.org/reference/

Transform

rotateX()
rotateY()
rotateZ()

- for the WEBGL render - 3D render for p5.js

applyMatrix()
resetMatrix()

-orientation and transformation state (0, 0 in top left, rotation, scaling)
-stored in a matrix of numbers

e.g.
1 0 0
0 1 0

2 x 3 matrix

When scaled:
2 0 0
0 2 0

-resetMatrix() - resets everything to the default state
-applyMatrix() - create own numbers, put into an array and then apply to a
matrix

setTimeout(_ , _);

2 arguments
1st - another function

e.g.
function rainbow() {

}

setTimeout(rainbow , _);

2nd - time in milliseconds

e.g.
setTimeout(rainbow , 2000);

2000 = 2 seconds

Meaning: code in raindow() will execute in 2 seconds from now

Often written as an anonymous function - can add in function code to first
argument without creating function

setInterval(_ , _)
-almost the same as setTimeout()
-will execute function (1st argument) every time given (2nd argument)

e.g.
setInterval(rainbow() , 2000)

-will execute rainbow every 2 seconds

CLOSURE:

function rainbow() {

}

function unicorn() {

}

is the same as

var rainbow = function()
var unicorn = function()

a function is stored in a variable

so a function can be defined inside another function

function rainbow() {
    function unicorn() {

    }
}

-unicorn() is a local variable to rainbow()
-can't call unicorn() outside of the rainbow()

function rainbow() {
    var counter = 0;

    function unicorn() {

    }
}

-counter is a local variable to the rainbow function

-When rainbow() is called a counter is stored in memory
-If rainbow() called again, a new counter is made
-When rainbow() is called, rainbow() is also stored in memory each time

9.7: Drawing Object Trails
https://www.youtube.com/watch?v=vqE8DMfOajk&list=PLRqwX-V7Uu6ZmA-d3D0iFIvgrB5_7kB8H&index=7

particle --> something moving around the screen
-has an x and y
-needs a history --> can be an array

Vectors:

var vector =

createVector(_,_); --> add in x & y

instead of

var x = _
var y = _

Vector acts as a way to get from the origin to where an element is displayed

9.8: Random Circles with No Overlap
https://www.youtube.com/watch?v=XATr_jdh-44&list=PLRqwX-V7Uu6ZmA-d3D0iFIvgrB5_7kB8H&index=8

Force-directed graph

Determining if circles are overlapping:
If distance between circles is greater than r1 + r2 = not overlapping
If distance between circles is less than or equal to r1 + r2 = overlapping

9.9: Minimum Spanning Tree (Prim's Algorithm)

https://www.youtube.com/watch?v=BxabnKrOjT0&list=PLRqwX-V7Uu6ZmA-d3D0iFIvgrB5_7kB8H&index=9

Minumum spanning trees
-A series of random points
-Connect all the points
-How can I find the minimum distance between points

Prim's Algorithm
-Start with a random point
-"unreached" and "unreached" vertices
-At start all are "unreached"
-Find point that has the least distance
-"Reach" two vertices - must find closest between these two and a third
-Check every "reached" vertex against every "unreached" vertex

2D Array:

-Array with 2 coordinates e.g. (3,1) - grid structure
-In computer memory is an array of arrays

Grid:

0   1   2   3
1   2   3   0
2   3   0   1
3   0   1   2

Computer:
[{0, 1, 2, 3}, {1, 2, 3, 0}, {2, 3, 0, 1}, {3, 0, 1, 2}]

Polar coordinates
https://www.youtube.com/watch?v=N633bLi_YCw&list=PLRqwX-V7Uu6ZmA-d3D0iFIvgrB5_7kB8H&index=20

-Point (x, y)
-Angle relative to point (angle)
-How to find 2nd point based on angle and distance
-Need a formula to convert from polar to cartesian (x, y)
-Need to use trigometric functions

-Know: (x1,y1), theta (angle), r
-Want to know 2nd point (x2, y2)

-If know dx (delta x = change in x) and (dy = change in y)

x1 + dx = x2
y1 + dy = y2

sin(theta) = dy / r     or  dy = r * sin(theta)
cos(theta) = dx / r     or  dy = r * cos(theta)

Custom Shapes
https://www.youtube.com/watch?v=76fiD5DvzeQ&list=PLRqwX-V7Uu6ZmA-d3D0iFIvgrB5_7kB8H&index=22

-To create a polygon - defined by its vertices (points that connect the sides)

Use function:

beginShape();
vertex(_,_);
vertex(_,_);
...
endShape();

curveVertex(_,_); --> curves edges

-Curves require additional points that control the entry and the exit of the curve
-Catmull-Rom Spline
